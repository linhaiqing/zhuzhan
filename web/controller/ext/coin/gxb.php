<?phpnamespace ext\coin;use function PHPSTORM_META\elementType;class gxb{	protected $host, $port, $version;	protected $id = 0;	function __construct($host, $port, $account, $password, $version = "2.0")	{		$this->host = $host;		$this->port = $port;		$this->account = $account;		$this->password = $password;		$this->version = $version;	}	function decode_hex($input)	{		if (substr($input, 0, 2) == '0x') {			$input = substr($input, 2);		}		if (preg_match('/[a-f0-9]+/', $input)) {			return hexdec($input);		}		return $input;	}	public function toWei($num, $type = "ether")	{		$typeMap = ['noether' => '0', 'wei' => '1', 'kwei' => '1000', 'Kwei' => '1000', 'babbage' => '1000', 'femtoether' => '1000', 'mwei' => '1000000', 'Mwei' => '1000000', 'lovelace' => '1000000', 'picoether' => '1000000', 'gwei' => '1000000000', 'Gwei' => '1000000000', 'shannon' => '1000000000', 'nanoether' => '1000000000', 'nano' => '1000000000', 'szabo' => '1000000000000', 'microether' => '1000000000000', 'micro' => '1000000000000', 'finney' => '1000000000000000', 'milliether' => '1000000000000000', 'milli' => '1000000000000000', 'ether' => '1000000000000000000', 'kether' => '1000000000000000000000', 'grand' => '1000000000000000000000', 'mether' => '1000000000000000000000000', 'gether' => '1000000000000000000000000000', 'tether' => '1000000000000000000000000000000'];		if (!isset($typeMap[$type])) {			$typenum = $typeMap['ether'];		} else {			$typenum = $typeMap[$type];		}		$len_typenum = strlen($typenum);		return $num * 100000000 . str_repeat("0", $len_typenum - 9) . "";	}	function fromWei($num, $type = "ether")	{		$typeMap = ['noether' => '0', 'wei' => '1', 'kwei' => '1000', 'Kwei' => '1000', 'babbage' => '1000', 'femtoether' => '1000', 'mwei' => '1000000', 'Mwei' => '1000000', 'lovelace' => '1000000', 'picoether' => '1000000', 'gwei' => '1000000000', 'Gwei' => '1000000000', 'shannon' => '1000000000', 'nanoether' => '1000000000', 'nano' => '1000000000', 'szabo' => '1000000000000', 'microether' => '1000000000000', 'micro' => '1000000000000', 'finney' => '1000000000000000', 'milliether' => '1000000000000000', 'milli' => '1000000000000000', 'ether' => '1000000000000000000', 'kether' => '1000000000000000000000', 'grand' => '1000000000000000000000', 'mether' => '1000000000000000000000000', 'gether' => '1000000000000000000000000000', 'tether' => '1000000000000000000000000000000'];		if (!isset($typeMap[$type])) {			$typenum = $typeMap['ether'];		} else {			$typenum = $typeMap[$type];		}		$type_len = strlen($typenum) - 1;		$num = $num . "";		$num_len = strlen($num);		if ($num_len > $type_len) {			$left_num = substr($num, 0, $num_len - $type_len);			$right_num = substr($num, -$type_len);			return num($left_num . "." . $right_num, 8);		} else {			return num("0." . str_repeat("0", $type_len - $num_len) . $num, 8);		}	}	function unlock()	{		$this->req(['method' => 'unlock']);	}	function get_balance()	{		$this->unlock();		return $this->req(['method' => 'list_account_balances']);	}	function get_info()	{		$this->unlock();		return $this->req(['method' => 'info']);	}	function check_success()	{		$balance = $this->get_balance();		if (isset($balance[0]['asset_id']) && $balance[0]['asset_id'] == '1.3.1') {			return true;		} else {			return false;		}	}	function get_trade_history($limit)	{		if (!$limit) {			$limit = 1;		}		$this->unlock();		$params = ['num' => $limit];		$res = $this->req(['method' => 'get_account_history', 'params' => $params]);		return $res;	}	function get_block($block)	{		$this->unlock();		$res = $this->req(['method' => 'get_block', 'params' => ['block_num' => $block]]);		return $res;	}	function get_id()	{		$this->unlock();		$res = $this->req(['method' => 'get_account']);		return $res;	}	function send_coin($to, $amount, $memo = null)	{		$this->unlock();		if (!$to || !$amount || !is_numeric($amount)) {			return ['转账参数错误'];		}		$params = ['to' => $to, 'amount' => round($amount, 5) . '',];		if ($memo) $params['memo'] = $memo;		$res = $this->req(['method' => 'transfer2', 'params' => $params]);		return $res;	}	function req($option = [])	{		$method = isset($option["method"]) ? $option["method"] : null;		$account = $this->account;		$password = $this->password;		$params = isset($option["params"]) ? $option["params"] : null;		$data = [];		$data['jsonrpc'] = $this->version;		$data['id'] = $this->id++;		$data['method'] = $method;		if (!$method || $method == 'unlock') {			$data['params'] = [$password];		} else if ($method == 'get_account' || $method == 'list_account_balances') {			$data['params'] = [$account];		} else if ($method == 'get_account_history') {			$limit = isset($params['num']) ? $params['num'] : 1;			$data['params'] = [$account, $limit];		} else if ($method == 'transfer' || $method == 'transfer2') {			$to = isset($params["to"]) ? $params["to"] : null;			$amount = isset($params["amount"]) ? $params["amount"] : null;			$memo = isset($params["memo"]) ? $params["memo"] : "";			if (!$to || !$amount) {				return ['转账缺少参数'];			}			$data['params'] = [$account, $to, $amount, 'GXS', $memo, true];		} else if ($method == 'get_block') {			$block_num = $params['block_num'];			$data['params'] = [$block_num];		} else {			$data['params'] = [];		}		if ($account) {			header('Authorization:Basic ' + base64_encode($account + ':' + $password));		}		$dataString = json_encode($data);		$curl = curl_init();		curl_setopt_array($curl, array(CURLOPT_PORT => $this->port, CURLOPT_URL => $this->host . ":" . $this->port . "/rpc", CURLOPT_RETURNTRANSFER => true, CURLOPT_ENCODING => "", CURLOPT_MAXREDIRS => 10, CURLOPT_TIMEOUT => 10, CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST => "POST", CURLOPT_POSTFIELDS => $dataString, CURLOPT_HTTPHEADER => array("cache-control: no-cache", "content-type: application/json"),));		$response = curl_exec($curl);		if ($response !== FALSE) {			$formatted = json_decode($response, true);			if (isset($formatted->error)) {				return [$formatted->error->message . $formatted->error->code];			} else {				return isset($formatted['result']) ? $formatted['result'] : '';			}		} else {			return ["Server did not respond"];		}	}	function request($method, $params = [], $type = null)	{		$data = [];		$data['jsonrpc'] = $this->version;		$data['id'] = $this->id++;		$data['method'] = $method;		$data['params'] = $params;		if ($type) {			$data = '{"jsonrpc":"2.0","id":1,"method":"eth_sendTransaction","params":[{"from":"0x38d2519D75BC25097655b7B9Cf47fD24fC3E7c5e","to":"0x6E2e3a1295E9d884d5653129f3986fA8F9d73eb5","value":"0x2386f26fc10000"}]}';		}		$ch = curl_init();		curl_setopt($ch, CURLOPT_URL, $this->host);		curl_setopt($ch, CURLOPT_PORT, $this->port);		curl_setopt($ch, CURLOPT_TIMEOUT, 8);		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);		curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);		curl_setopt($ch, CURLOPT_POST, TRUE);		if ($type) {			curl_setopt($ch, CURLOPT_POSTFIELDS, ($data));		} else {			curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));		}		$ret = curl_exec($ch);		if ($ret !== FALSE) {			$formatted = json_decode($ret, true);			if (isset($formatted->error)) {				return [$formatted->error->message . $formatted->error->code];			} else {				return isset($formatted['result']) ? $formatted['result'] : '';			}		} else {			return ["Server did not respond"];		}	}} 